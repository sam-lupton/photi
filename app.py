from io import BytesIO

import numpy as np
import streamlit as st
import cv2
from  PIL import Image, ImageEnhance

# Ensures the page title (i.e. the tab name) will be Photi rather than app · Streamlit
st.set_page_config(page_title="Photi")

#Create two columns with different width
col1, col2 = st.columns( [0.8, 0.2])
with col1:               # To display the header text using css style
    st.markdown(""" <style> .font {
    font-size:35px; font-weight: bold; color: #800080;} 
    </style> """, unsafe_allow_html=True)
    st.markdown('<p class="font">Add a photo here...</p>', unsafe_allow_html=True)

#Add a header and expander in side bar
st.sidebar.markdown('<p class="font">Photi: an image generator and editor</p>', unsafe_allow_html=True)
with st.sidebar.expander("About the app"):
     st.write("""
        With this app, you can perform a variety of editing and machine learning tasks on photos, like adjusting colour saturation and contrast, as well as edge detection and pencil sketching. Photos can be uploaded manually or generated by AI using DALL-E Mini.

        This app was created by Sam Lupton as part of the Harvard CS50 course.
     """)

# Initialise a 'picture' veriable in the session's state, allowing persistence of photos between function calls
# Streamlit reruns the whole script every time a user clicks something, so photos would be lost otherwise!
if 'picture' not in st.session_state:
    st.session_state.picture = None

picture = st.session_state.picture

def get_image():
    image_type = st.radio(
        "How would you like to input your image?",
        ('Upload from hard drive', 'Generate from a text prompt using AI'))

    if image_type == 'Upload from hard drive':
        picture = st.file_uploader('Picture', type=['jpg','png','jpeg'], label_visibility='collapsed')
        if picture:        
            picture = Image.open(picture)
            # Persist image between function calls
            st.session_state.picture = picture
            return picture
    elif image_type == 'Generate from a text prompt using AI':
            model_name = st.radio(
                "Pick which model to use. Note: DALL-E Mini is preferred unless using a high-performance computer",
                ('DALL-E Mini', 'DALL-E Mega'))

            st.markdown(
                """
                Some points to bear in mind when generating images with DALL-E:
                - The model struggles with human faces and animals. Unless you're looking for nightmarish and/or hilarious results, try to avoid these.
                - However, the model captures genres and artists' styles well, so you can write 'A landscape in the style of Dali'.
                - The model can take 5-10 minutes to run, so go make yourself a coffee!
                """
                )
            prompt = st.text_input(label='Type the text for your desired image here:')

            if model_name and prompt:
                if st.button("Generate image"):
                    st.write("Creating image from model. This may take some time...")
                    model_size = 'mini' if model_name == 'DALL-E Mini' else 'mega'
                    from dalle import generate_image_from_text
                    time_elapsed, picture = generate_image_from_text(prompt, model_size=model_size)

                    # Inform the user if results were previously cached
                    if st.session_state.get("cache_updated", False):
                        st.write(f"Results returned in {time_elapsed} seconds.")
                    else:
                        st.write(f"Results returned from cache, previously generated in {time_elapsed} seconds.")

                    # Persist between function calls
                    st.session_state.picture = picture
                    return picture

# Only call get_image() function if a picture has not been found in the session state
if not picture:
    picture = get_image()
    st.session_state["cache_updated"] = False

# Add a 'clear image' button to start again
if picture:
    if st.button("Clear image and start again"):
        picture = st.session_state.picture = None
        picture = get_image()
        st.session_state["cache_updated"] = False

if picture:
    image = picture
    
    col1, col2 = st.columns( [0.5, 0.5])
    with col1:
        st.markdown('<p style="text-align: center;">Before</p>',unsafe_allow_html=True)
        st.image(image, width=300)
        st.write("← Now use the left sidebar to edit the photi")

    #Add conditional statements to take the user input values
    with col2:
        st.markdown('<p style="text-align: center;">After</p>',unsafe_allow_html=True)
        filter = st.sidebar.radio('Convert your photo to:', ['Original', 'Gray Image', 'Black and White', 'Colour', 'Contrast', 'Brightness', 'Pencil Sketch', 'Blur Effect', 'Canny Edge Detector', 'Contours'])
        if filter == 'Gray Image':
                converted_img = np.array(image.convert('RGB'))
                gray_scale = cv2.cvtColor(converted_img, cv2.COLOR_RGB2GRAY)
                st.image(gray_scale, width=300)
        elif filter == 'Black and White':
                converted_img = np.array(image.convert('RGB'))
                gray_scale = cv2.cvtColor(converted_img, cv2.COLOR_RGB2GRAY)
                slider = st.sidebar.slider('Adjust the intensity', 1, 255, 127, step=1)
                (thresh, blackAndWhiteImage) = cv2.threshold(gray_scale, slider, 255, cv2.THRESH_BINARY)
                st.image(blackAndWhiteImage, width=300)
        elif filter == 'Colour':
                enhancer = ImageEnhance.Color(image)
                slider = st.sidebar.slider('Adjust the intensity', 0.0, 2.0, 1.0)
                contrast_image =  enhancer.enhance(slider)
                st.image(contrast_image, channels='BGR', width=300)
        elif filter == 'Contrast':
                enhancer = ImageEnhance.Contrast(image)
                slider = st.sidebar.slider('Adjust the intensity', 0.0, 2.0, 1.0)
                contrast_image =  enhancer.enhance(slider)
                st.image(contrast_image, channels='BGR', width=300)
        elif filter == 'Brightness':
                enhancer = ImageEnhance.Brightness(image)
                slider = st.sidebar.slider('Adjust the intensity', 0.0, 2.0, 1.0)
                contrast_image =  enhancer.enhance(slider)
                st.image(contrast_image, channels='BGR', width=300)
        elif filter == 'Pencil Sketch':
                converted_img = np.array(image.convert('RGB')) 
                gray_scale = cv2.cvtColor(converted_img, cv2.COLOR_RGB2GRAY)
                inv_gray = 255 - gray_scale
                slider = st.sidebar.slider('Adjust the intensity', 25, 255, 125, step=2)
                blur_image = cv2.GaussianBlur(inv_gray, (slider,slider), 0, 0)
                sketch = cv2.divide(gray_scale, 255 - blur_image, scale=256)
                st.image(sketch, width=300) 
        elif filter == 'Blur Effect':
                converted_img = np.array(image.convert('RGB'))
                slider = st.sidebar.slider('Adjust the intensity', 5, 81, 33, step=2)
                converted_img = cv2.cvtColor(converted_img, cv2.COLOR_RGB2BGR)
                blur_image = cv2.GaussianBlur(converted_img, (slider,slider), 0, 0)
                st.image(blur_image, channels='BGR', width=300)
        elif filter == 'Canny Edge Detector':
            converted_img = np.array(image.convert('RGB'))
            edges = cv2.Canny(converted_img,50,300)
            st.image(edges, width=300)
        elif filter == 'Contours':
            converted_img = np.array(image.convert('RGB'))
            y = st.sidebar.slider('Change value to increase or decrease contours',min_value = 50,max_value = 255) 
            imgray = cv2.cvtColor(converted_img, cv2.COLOR_BGR2GRAY)
            ret, thresh = cv2.threshold(imgray, y, 255, 0)
            contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
            
            converted_img = cv2.drawContours(converted_img, contours, -1, (0,255,0), 3)
            st.image(converted_img, width=300)
        else: 
                st.image(image, width=300)

        # Implement download button, letting user pick name
        st.write("Name your photi below, ready for download")
        name = st.text_input("Name", label_visibility="collapsed")
        
        if name:
            buf = BytesIO()
            image.save(buf, format="JPEG")
            byte_im = buf.getvalue()

            btn = st.download_button(
                label=f"Download {name}.jpeg",
                data=byte_im,
                file_name=f"{name}.jpeg",
                mime="image/jpeg",
                )